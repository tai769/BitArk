# BitArk 核心设计日志：LSN (Log Sequence Number) 的诞生与物理坐标映射

**日期：** 2026-01-26  
**设计者：** BitArk 架构团队  
**状态：** 基础骨架已落地 (Phase 1.1)

---

## 1. 为什么需要 LSN？（第一性原理）

在分布式存储系统中，LSN（日志序列号）是数据的“身份证”和系统的“刻度尺”。

*   **唯一性**：每一条写入系统的日志必须有一个全局唯一的、单调递增的标识。
*   **进度衡量**：主从之间不再说“我发了几个包”，而是说“我追到了哪个刻度”。没有刻度，就无法衡量主从之间的“距离”。
*   **自愈基础**：当 Slave 断线重连时，它只需要告诉 Master 它的 `lastAppliedLSN`，Master 就能精准计算出需要补发哪一段数据。

---

## 2. 核心设计：从“逻辑刻度”到“物理坐标”

### 玩具版本（弃用方案）
在 `Engine` 层维护一个简单的自增 `long`。
*   **弊端**：并发竞争大（需要全局锁）；重启后逻辑 ID 与磁盘文件的物理位置（Offset）映射关系复杂，恢复慢。

### 工业级版本（当前采用）
将 LSN 直接映射为 **物理坐标：(SegmentIndex, FileOffset)**。
*   **优势**：
    *   **零转换开销**：LSN 本身就是文件地址，定位数据只需一次 `seek`。
    *   **绝对准确**：由刷盘的 IO 线程在数据入库瞬间产生，保证了“分配即落盘”。

---

## 3. 技术实现细节：IO 欠条模式 (The IO IOU Pattern)

由于我们采用了 **Group Commit (组提交)** 技术，多条日志会合并成一个批次异步刷盘。这导致业务线程在调用 `append` 时无法预知准确的物理位置。

### 核心改进点：
1.  **位置下沉 (Placement)**：
    将 LSN 的生成逻辑从业务线程下沉到最内层的 `WalWriter_V2` 的 `ioLoop` 线程中。
2.  **物理偏移计算公式**：
    `lsnOffset = fileChannel.position() + writeBuffer.position();`
    *   `fileChannel.position()`：当前文件已经刷盘的进度。
    *   `writeBuffer.position()`：当前批次中，该条数据在缓冲区内的起点。
    *   **原理**：在数据被序列化到 Buffer 之前的那一刻，这两个值之和就是该记录在磁盘上的精确物理偏移。
3.  **异步桥接 (Future Bridge)**：
    *   业务线程提交请求，领走一个 `CompletableFuture<WalCheckpoint>`（欠条）。
    *   IO 线程完成物理位置分配和刷盘后，通过 `future.complete(lsn)` 兑现欠条。
    *   `GroupCommitWalEngine` 使用 `.join()` 同步等待结果，完成从异步 IO 到同步业务的平滑衔接。

---

## 4. 架构价值总结

*   **高性能无锁**：物理刻度的产生由单线程 IO 驱动，完全避开了业务层的高并发锁竞争。
*   **职责解耦**：
    *   `WalWriter`：物理位置的唯一知情者。
    *   `WalEngine`：进度的中转与调度者。
    *   `ReadService`：进度的使用者（拿着 LSN 做主从同步）。
*   **未来扩展性**：这套物理 LSN 框架为后续的 **CRC 校验、主从自愈、慢从机流控** 提供了标准化的数据底座。

---
*BitArk - 构建高性能、高可用的分布式已读服务底座*
